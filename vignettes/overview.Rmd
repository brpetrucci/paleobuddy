---
title: "Paleobuddy overview"
author: Bruno do Rosario Petrucci
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
`paleobuddy` is an R package for species birth-death simulation, complete with the possibility of generating phylogenetic trees and fossil records from the results. The package offers unprecedented flexibility in the choice of speciation, extinction and sampling rates, as we will showcase in this vignette. 

The biggest reason to write and publish a simulator is to effectively test rate estimation methods with scenarios whose true dynamics are known. This leads to an intuitive overview of the package: in this vignette, we will first generate a couple of useful scenarios to show use cases of the package. Then, we will discuss the choice of rates further, detailing the customization capabilities of both the birth-death and sampling functions. Finally, we will conclude going over the shortcomings of the package, including the features we plan to implement in the future. As new versions are released, this document will be updated to reflect the newest features.

First we do some setup.

```{r results = "hide"}
# importing the package functions
library(paleobuddy)
```

## Constant rate birth-death: a use case with phytools

Let us first try the simplest possible birth-death scenario - constant speciation and extinction rates. We will then use `phytools` to attempt an estimate of rates.

First we use the function `bd.sim`, the main birth-death simulator in the package, to generate a group.

```{r}
# we set a seed so the results are reproducible
set.seed(1)

# set the necessary parameters
# initial number of species
n0 <- 1

# speciation rate - approx. 1 speciation event every 4my
# we are trying to create a big phylogeny so phytools can function better
lambda <- 0.25

# extinction rate - approx. 1 extinction event every 10my
mu <- 0.15

# maximum simulation time - species that die after this are considered extant
tMax <- 50

# run the simulation
sim <- bd.sim(n0, lambda, mu, tMax)

# take a look at the way the result is organized
sim
```

The output of `bd.sim` is a `sim` object, a class made up of named vectors that is organized as follows

  * `TE` a list of extinction times. For an extant species, the extinction time is `NA`.
  * `TS` a list of speciation times. For species alive at the beginning of the simulation, the speciation time is `tMax`.
  * `PAR` a list of parents. The naming of species follows the order of `TE` and `TS`, i.e. if `PAR[i] == 1`, the species whose speciation time is `TS[1]` generated species `i`.
  * `EXTANT` a list of booleans indicating whether a species is alive at the end of the simulation or not. Note this could be extrapolated from the information in `TE`, but we present it for practicality's sake.

Using this object, or one generated by `bd.sim.constant` or `bd.sim.general`, the helper functions `bd.sim` calls, we can generate a phylogenetic tree using `make.phylo`.

```{r}
# there are currently not many customization options for phylogenies
phy <- make.phylo(sim)

# plot it with APE - hide tip labels since there are a lot so it looks cluttered
ape::plot.phylo(phy, show.tip.label = FALSE)
ape::axisPhylo()

# plot the molecular phylogeny
ape::plot.phylo(ape::drop.fossil(phy), show.tip.label = FALSE)
ape::axisPhylo()
```

From here, we could use this phylogeny to run `phytools` and get an estimate of the speciation and extinction rate.

```{r eval=FALSE}
# find the fit
fit <- phytools::fit.bd(ape::drop.fossil(phy))
fit
```

We set this to not run so that we do not need to add phytools as an Import in the package, but the results were approximately `b = 0.21` and `d = 0.22`. As we can see, `phytools` overestimated extinction and underestimated speciation, something common since there are two independent processes going on, births and deaths. A phylogeny with more species could lead to more accurate results, and of course if we were conducting a thorough test of `phytools` we would generate hundreds or thousands of phylogenies.

For illustration, we create a simulation with more than 1000 tips, with 547 extant tips.

```{r}
# set a seed
set.seed(3)

# create simulation
# note nExtant, defining we want 200 or more extant species at the end
sim <- bd.sim(n0, lambda, mu, tMax, nExtant = c(200, Inf))

# check the number of extant species
sum(sim$EXTANT)
```

We can then run this through `phytools` as before

```{r eval=FALSE}
# find the fit
fit <- phytools::fit.bd(ape::drop.fossil(make.phylo(sim)))
fit
```

This yields a warning, because of the gigantic phylogeny, but also yields `b = 0.28` and `d = 0.18`. Pretty great fits, especially when considering how challenging it is to estimate extinction rates with a molecular phylogeny, and the fact we conditioned the results when we asked `bd.sim` to only give us a simulation with 200 or more extant species.

## Linear speciation and extinction: a use case with PyRate and Foote's Per Capita

One of the pluses of `paleobuddy` is that we can generate both fossil records and phylogenies in independent processes, both coming from the same underlying birth-death simulations. We will here use the fossil record generating functions of `paleobuddy` to generate a fossil record and prepare the output for use with PyRate (Silvestro et al 2014) and Foote's Per Capita method (Foote 2000)

As before, start with a simulation

```{r}
# we set a seed so the results are reproducible
set.seed(5)

# set the necessary parameters
# initial number of species
n0 <- 1

# speciation rate - it can be any function of time!
lambda <- function(t) {
  0.1 + 0.001*t
}

# extinction rate - also can be any function of time
mu <- function(t) {
  0.03 * exp(-0.01*t)
}

# maximum simulation time - species that die after this are considered extant
tMax <- 50

# run the simulation
sim <- bd.sim(n0, lambda, mu, tMax)

# check the resulting clade out
ape::plot.phylo(make.phylo(sim), show.tip.label = FALSE)
```

A lot of species! We can then create a fossil record from this group.

```{r}
# again set a seed
set.seed(1)

# set the sampling rate
# using a simple case - there will be on average T occurrences per species,
# where T is the species duration
rho <- 1

# run the sampling simulation only for the first 15 species for brevity's sake
# returnTrue = FALSE makes it so the occurrences are binned (i.e. an occurrence
# at time 42.34 is between 42.4 and 42.3)
samp <- suppressMessages(sample.clade(sim = sim, rho = rho, 
                                      tMax = tMax, S = 1:15, returnTrue = FALSE))
# suppressing messages - the message is to inform the user how many species
# left no fossils. In this case, it was 0

# take a look at how the output is organized
head(samp)
```

The output of `sample.clade` is a data frame organized as follows

* `Species` the species name, usually `t` followed by the number in the order it is organized on `sim`.
* `Extant` whether the species is extant or not.
* `minT` the lower bound of the geologic range the fossil is found. The range vectors is an input, `bins`, used to simulate the granularity of the fossil record. If not provided, `bins` will go from `tMax` to `0` by `-0.01`.
* `maxT` the upper bound of the geologic range the fossil is found.

This data frame organization allows for easy evaluation of its components, and is close to ready for use in PyRate, one of the most widely used birth-death rates estimators in the field currently. To make it ready we must manipulate the `Extant` column, left like this for clarity. In PyRate, that column must be `status`, with extant species marked `extant` and extinct species marked `extinct`.

```{r}
# make a copy
pSamp <- samp

# change the extant column
pSamp["Extant"][pSamp["Extant"] == FALSE] = "extant"
pSamp["Extant"][pSamp["Extant"] == TRUE] = "extinct"

# change column names
colnames(pSamp) <- c("Species", "Status", "min_age", "max_age")

# check it out
head(pSamp)
```

This data frame could be directly dropped in PyRate for rate estimations. 

We can also use `RMark` or other simpler methods to check estimations. Let us write a quick function applying Foote's Per Capita method.

```{r}
per.capita <- function(faBins, laBins, bins) {
  # create vectors to hold species that were born before and die in interval i,
  # species who were born in i and die later,
  # and species who were born before and die later
  NbL <- NFt <- Nbt <- rep(0, length(bins))
  
  # for each interval
  for (i in 1:length(bins)) {
    # number of species that were already around before i and are not seen again
    NbL[i] <- sum(faBins > bins[i] & laBins == bins[i])
    
    # number of species that were first seen in i and are seen later
    NFt[i] <- sum(faBins == bins[i] & laBins < bins[i])
    
    # number of species that were first seen before i and are seen after i
    Nbt[i] <- sum(faBins > bins[i] & laBins < bins[i])
  }
  
  # calculate the total rates
  p <- log((NFt + Nbt) / Nbt)
  q <- log((NbL + Nbt) / Nbt)
  return(list(p = p, q = q))
}
```

To apply this function, we need to manipulate `samp` a little bit

```{r}
# get the species names
ids <- unique(samp$Species)

# get the first appearance bins - the first time in bins where the fossil was seen (lower bound)
faBins <- unlist(lapply(ids, function(i) max(samp$MaxT[samp$Species == i])))

# get the last appearance bins - last time in bins where the fossil was seen (upper bound)
laBins <- unlist(lapply(ids, function(i) min(samp$MinT[samp$Species == i])))

# create the bins vector we have been using
bins <- seq(tMax, 0, -0.1)
# note this has a high resolution, the actual stratigraphic ranges are much coarser

# get the estimates
pc <- per.capita(faBins, laBins, bins)
```

This method assumes perfect sampling, so it will not be a good estimate, but it is nevertheless a good example of `sample.cade` use. One could then clean up `pc` and plot the rates, but for sampling as imperfect as we have here it will not be a good estimate.

Other examples of methods using only the fossil record are Capture-Mark-Recapture (Liow & Nichols 2010) and the Alroy 3-timer (Alroy 2014). One could also use `paleobuddy` to test methods that integrate fossil records and phylogenies, such as the Fossilized birth-death model (Stadler et al 2010, Heath et al 2014). While a thorough test of these methods are not in the scope of this vignette, we believe to have shown the workflow required for such tests.

## paleobuddy's flexibility

While showing use cases of the package is great, we should also spend some time detailing the possible customization options in `bd.sim` and `sample.clade`.

We have already shown speciation and extinction rates can be any function of time, or constant numbers. Let us check some other possibilities out.

```{r}
# set a seed
set.seed(2)

# parameters to set things up
n0 <- 1
tMax <- 20

# speciation can be dependent on an environmental variable as well as time
lambda <- function(t, env) {
  0.01 * t + 0.01*exp(0.01*env)
}

# let us use the package's temperature data
data(temp)
# this could also be data(co2), the other environmental data frame supplied by
# paleobuddy

# we can make extinction be age-dependent by creating a shape parameter
mu <- 10
mShape <- 0.5
# this will make it so species durations are distributed as a Weibull with scale 10 and shape 2

# run the simulation
# we pass the shape and environmental parameters
sim <- bd.sim(n0, lambda, mu, tMax, mShape = mShape, envL = temp)
# note that lShape and envM also exist
# the defaults for all of these customization options is NULL

# check out the phylogeny
ape::plot.phylo(make.phylo(sim), show.tip.label = FALSE)
```

So as to avoid repetition, we will not run simulations for the next possibilities, but we will list them

```{r}
# speciation may be a step function, presented as a rates vector and a shift times vector
lList <- c(0.1, 0.2, 0.05)
lShifts <- c(0, 10, 15)
# lShifts could also be c(tMax, tMax - 10, tMax - 15) for identical results

# make.rate is the function bd.sim calls to create a rate, but we will use it here to see how it looks
lambda <- make.rate(lList, tMax = 20, rateShifts = lShifts)
t <- seq(0, 20, 0.1)
plot(t, lambda(t), type = 'l', main = "Step function speciation rate",
     xlab = "Time (My)", ylab = "Rate")

# it is not possible to combine the lambda(t, env) and lList methods listed above
# but we can create a step function dependent on environmental data with ifelse
q <- function(t, env) {
  ifelse(t < 10, env,
         ifelse(t < 15, env * 2, env / 2))
}

# pass it to make.rate with environmental data
mu <- make.rate(q, tMax = tMax, envRate = temp)
plot(t, mu(t), type = 'l', main = "Environmental step function extinction rate",
     xlab = "Time (My)", ylab = "Rate")
```

Note all these customization options could serve for a weibull scale as well, if the user wishes to have age-dependent speciation and/or extinction. The possibility of age-dependency with time-varying rates is, to our knowledge, exclusive to `paleobuddy`.

```{r eval=FALSE}
# set seed again
set.seed(1)

# age-dependent speciation with a step function
lList <- c(10, 5, 12)
lShifts <- c(0, 10, 15)
lShape <- 2

# age-dependent extinction with a step function of an environmental variable
q <- function(t, env) {
  ifelse(t < 10, 2*env,
         ifelse(t < 15, 1.4*env, env / 2))
}

# note shape can be time-dependent as well, though
# we advise for variation not to be too abrupt due
# to computational issues
mShape <- function(t) {
  return(1.2 + 0.025*t)
}

# run the simulation
sim <- bd.sim(n0, lList, q, tMax, lShape = lShape, mShape = mShape, envM = temp, lShifts = lShifts)

# check out the phylogeny
ape::plot.phylo(make.phylo(sim), show.tip.label = FALSE)
```

We set this to not run because it takes a long time - both because of the high speciation and because the method of creating a step function rate with `shifts` and `lists` takes a long time to integrate. It is however a good illustration of the power of `paleobuddy`s flexibility. 

None of the scenarios we have listed here are specific to speciation or extinction - one can mix and match any combination listed here for either rate. 

In the case of sampling rates, it is almost the case that any scenario available to speciation/extinction is available to sampling. We do not allow for a `shape` parameter since the Weibull distribution is not frequently used in the literature for age-dependent sampling. Instead, we allow for the user to supply a probability distribution signifying how occurrences are distributed along a species age, as follows

```{r}
# as an example, we will use a PERT distribution, a hat-shaped distribution used in PyRate
# preservation function
dPERT <- function(t, s, e, sp, a = 3, b = 3, log = FALSE) {

  # check if it is a valid PERT
  if (e >= s) {
    message("There is no PERT with e >= s")
    return(rep(NaN, times = length(t)))
  }

  # find the valid and invalid times
  id1 <- which(t <= e | t >= s)
  id2 <- which(!(t <= e | t >= s))
  t <- t[id2]

  # initialize result vector
  res <- vector()

  # if user wants a log function
  if (log) {
    # invalid times get -Inf
    res[id1] <- -Inf

    # valid times calculated with log
    res[id2] <- log(((s - t) ^ 2)*((-e + t) ^ 2)/((s - e) ^ 5*beta(a,b)))
  }
  # otherwise
  else{
    res[id1] <- 0

    res[id2] <- ((s - t) ^ 2)*((-e + t) ^ 2)/((s - e) ^ 5*beta(a,b))
  }

  return(res)
}

# set seed
set.seed(1)

# generate a quick simulation
sim <- bd.sim(n0, lambda = 0.1, mu = 0.05, tMax = 20)

# we will need to use sim$TE, so let us make the extant species' time 0
sim$TE[sim$EXTANT] <- 0

# another seed
set.seed(1)

# sample - high sampling rate so we can visualize the age-dependency
samp <- sample.clade(sim = sim, rho = 30, tMax = 20, 
                     returnTrue = FALSE, adFun = dPERT)
# if no bin is supplied and returnTrue = FALSE, it uses seq(tMax, 0, -0.1)
# as a high resolution default

# extract species identity
ids <- unique(samp$Species)

# approximate sampling time (since it is a range)
mids <- (samp$MaxT - samp$MinT) / 2 + samp$MinT

# for each species
for (i in 1:length(ids)) {
  # get the species number
  sp <- unique(as.numeric(gsub("t", "", ids[i])))

  # check the histogram
  hist(mids[samp$Species == ids[[i]]],
       main = paste0("t = ", sp, "; duration ~ ",
                     round(sim$TS[sp] - sim$TE[sp], digits = 2), "my"),
       xlab = "Time (My)", probability = TRUE)

  # expected curve
  curve(dPERT(x, s = sim$TS[sp], e = sim$TE[sp], sp = sp), from = sim$TE[sp],
        to = sim$TS[sp], add = TRUE, col = "red", n = 100)
}
```

For more details and examples of age-dependent models, check out `?sample.age.time` and `?sample.clade`. Even if an `adFun` argument is supplied for age dependency, the average sampling rate `rho` may have the same flexibility. We omit examples of other sampling rate options since they are just the same options as birth-death rates, excluding shape parameters.

## Conclusion

For completion, we present a final list of the functions of the package

* `bd.sim` birth-death simulator. Rates can be constant, time dependent, time and enviromentally dependent, or a list of numbers. User can supply a shape parameter to make rate a Weibull scale.
* `bd.sim.constant` function called by `bd.sim` when rates are constant.
* `bd.sim.general` function called by `bd.sim` when they are not.
* `make.phylo` creates a `phylo` object from the `ape` package.
* `sample.clade` samples a whole group, usually outputted from `bd.sim`. Sampling rate can be anything a speciation or extinction rate can be, without the option of a shape parameter. The user may instead supply a distribution of ocurrences accross a species age, so as to simulate age-dependency in sampling with more flexibility.
* `sample.time` function called by `sample.clade` when sampling is not age-dependent
* `sample.age.time` function called by `sample.clade` when sampling is age-dependent (i.e. Age Dependent Poisson Process)
* `rexp.var` exponential and weibull waiting time drawing with variable rates. Used by `bd.sim` and `sample.clade`.
* `find.lineages` separates a group returned by the `bd.sim` function, or similar, by the species that started the simulation as mothers of each group. Allows for an optional argument, a list of numbers, and if supplied returns the groups generated by those species instead. A quick example:

```{r}
# set a seed 
set.seed(1)

# simple simulation, starting with more than one species
sim <- bd.sim(n0 = 2, lambda = 0.1, mu = 0, tMax = 20, nFinal = c(20, Inf))

# separate the lineages
clades <- find.lineages(sim)

# plot each phylogeny

# clade 1
ape::plot.phylo(make.phylo(clades$clade_1$sim), show.tip.label = FALSE)

# clade 2
ape::plot.phylo(make.phylo(clades$clade_2$sim), show.tip.label = FALSE)
```

* `phylo.to.sim` creates a `sim` object from a phylogeny following the APE `phylo` class format (Paradis et al 2004). Can be used to integrate paleobuddy with other packages that output phylogenies. Note that the user must supply some optional arguments to allow for this; most importantly the information of each species' mother, since this is ambiguous from a bifurcating phylogeny.
* `make.rate` creates a function of time from the customization options presented above - vector of numbers and vector of shif times, function of time and environment and an environment matrix, etc. Used by `bd.sim` and `sample.clade` to detect when the given rates are constant, and create the rates to pass to the helper functions.
* `var.rate.div` calculates the expected diversity from a variable rate birth-death process and a time period.
* `binner` given occurrence times and time bins, returns the number of occurrences in each bin.
* Finally, there are a number of generics and methods for the `sim` class, like `print.sim` and `plot.sim`. See `?sim` for a detailed list.

While the package is robust and flexible, it is useful to spend a little time discussing the shortcomings and planned features.

* Currently, time-varying shape is an untested feature of the package. This is a glaring omission given that time-varying scale is well tested, and we plan on devising better testing methods so we can effectively present this as a feature.
* The method of generating step functions from rate and shift times vectors is currently very slow (see `?make.rate`), and we plan on looking for more efficient alternatives. Meanwhile, the user might prefer the creation of step functions using `ifelse` when prioritizing efficiency.
* A couple of diversification scenarios are very well established in the literature and therefore are planned for future versions of the package: trait-dependent diversification, diversity-dependent rates, anagenesis/bifurcating speciation, etc.
