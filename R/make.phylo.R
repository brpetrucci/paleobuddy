#' Phylogeny generating
#'
#' Generates a phylogeny from a \code{sim} object containing speciation and 
#' extinction times, parent and status information (see \code{?sim}). Returns a
#' \code{phylo} object containing information on the phylogeny, following an 
#' "evolutionary Hennigian" (sensu Ezard et al 2011) format. Takes an optional
#' argument encoding fossil occurrences to return a Sampled Ancestor tree (see
#' references), with fossil occurrences as tips with branch length \code{0}.
#' Returns \code{NA} and sends a warning if the simulation has only one lineage or
#' if more than one species has \code{NA} as parent (i.e. there is no single 
#' common ancestor in the simulation). In the latter case, please use 
#' \code{find.lineages} first. 
#'
#' @param sim A \code{sim} object, containing extinction times, speciation times,
#' parent, and status information for each species in the simulation. See 
#' \code{?sim}.
#' 
#' @param fossils A data frame with a \code{"Species"} column and a
#' \code{SampT} column, usually an output of the \code{sample.clade}
#' function. Species names must contain only one number each, corresponding
#' to the order of the \code{sim} vectors.
#'
#' @return A \code{phylo} object from the APE package. Tip labels are numbered
#' following the order of species in the \code{sim} object. If fossil occurrence
#' data was supplied, the tree will include fossil occurrences as tips with branch
#' length \code{0}, bifurcating at its sampling time from the corresponding
#' species' edge (i.e. a sampled ancestor tree, sensu Heath et al, (2014)). Note
#' that to obtain a true SA tree, one must perform the last step of deleting tips
#' that are not either extant or fossil occurrences (i.e. the tips at true time of
#' extinction).
#' 
#' Note this package does not depend on APE (Paradis et al, 2004) since it is 
#' never used inside its functions, but it is suggested since one might want to
#' manipulate the phylogenies generated by this function.
#' 
#' @author Matheus Januario and Bruno do Rosario Petrucci
#' 
#' @references
#' 
#' Ezard, T. H., Pearson, P. N., Aze, T., & Purvis, A. (2012). The meaning of 
#' birth and death (in macroevolutionary birth-death models). Biology letters, 
#' 8(1), 139-142.
#' 
#' Paradis, E., Claude, J., Strimmer, & K. (2004). APE: Analyses of Phylogenetics
#' and Evolution in R language. Bioinformatics, 20(2), 289-290.
#' 
#' Heath, T. A., Huelsenbeck, J. P., & Stadler, T. (2014). The fossilized 
#' birthâ€“death process for coherent calibration of divergence-time estimates. 
#' Proceedings of the National Academy of Sciences, 111(29), E2957-E2966.
#'
#' @examples
#'
#' ###
#' # generating a phylogeny using constant rates
#' sim <- bd.sim(n0 = 1, lambda = 0.2, mu = 0.05, tMax = 10, 
#'              nExtant = c(2, Inf))
#' 
#' # make the phylogeny
#' phy <- make.phylo(sim)
#' 
#' par(mfrow = c(1, 2))
#' # plot it
#' if (requireNamespace("ape", quietly = TRUE)) {
#'   ape::plot.phylo(phy)
#'   
#'   # we can also plot only the molecular phylogeny
#'   ape::plot.phylo(ape::drop.fossil(phy))
#' }
#' 
#' ###
#' # this works for sim generated with any of the scenarios in bd.sim, of course
#' sim <- bd.sim(n0 = 1, lambda = function(t) 0.05 + 0.01*t, 
#'              mu = function(t) 0.03 + 0.015*t, tMax = 10, 
#'              nExtant = c(2, Inf))
#' 
#' # make the phylogeny
#' phy <- make.phylo(sim)
#' 
#' ### 
#' # Let us try out the fossils argument to generate a Sample Ancestor tree
#' 
#' # simulate a simple birth-death process
#' sim <- bd.sim(n0 = 1, lambda = 0.2, mu = 0.05, tMax = 10, 
#'               nExtant = c(2, Inf))
#' 
#' # make the traditional phylogeny
#' phy <- make.phylo(sim)
#' 
#' # sample fossils
#' fossils <- sample.clade(sim, 0.1, 10)
#' 
#' # make the sampled ancestor tree
#' saTree <- make.phylo(sim, fossils)
#' 
#' par(mfrow = c(1, 2))
#' # plot them
#' if (requireNamespace("ape", quietly = TRUE)) {
#'   ape::plot.phylo(phy, main = "Phylogenetic tree")
#'   ape::axisPhylo()
#'   
#'   ape::plot.phylo(saTree, main = "Sampled Ancestor tree")
#'   ape::axisPhylo()
#' }
#' 
#' @name make.phylo
#' @rdname make.phylo
#' @export

make.phylo <- function(sim, fossils = NULL) {
  # check that sim is a valid sim object
  if (!is.sim(sim)) {
    stop("Invalid argument, must be a sim object. See ?sim")
  }
  
  # simulations with just one species do not have a phylogeny
  if (length(sim$TE) < 2) {
    message("There is no phylogeny for a simulation with only one lineage")
    return(NA)
  }

  # simulations with more than one starting species have multiple phylogenies
  if (sum(is.na(sim$PAR)) > 1) {
    message("Multiple starting species. Use function find.lineages")
    return(NA)
  }
  
  # if fossils are provided, make a sampled ancestor tree instead
  if (!is.null(fossils)) {
    
    if (nrow(fossils) == 0) {
      stop("Please insert a data frame containig fossil data. 
           See ?make.phylo for more information.")
    }
    
    # make Species field of fossils numeric
    fossils$Species <- as.numeric(gsub('.([0-9]+)*','\\1', fossils$Species))
    
    # get a list of sample species
    sampledSpecies <- unique(c(which(sim$EXTANT), fossils$Species))
    
    # if any of them are not in the sim range, error
    if (any(!(sampledSpecies %in% 1:length(sim$TE)))) {
      stop("Sampled species must all be in sim")
    }
    
    # start the vector with names
    names <- paste0("t", 1:length(sim$TS))
    sampledNames <- paste0("t", which(sim$EXTANT))
    
    # fossil count for each species
    count <- 1
    
    # previous fossil species starting count
    prevFossil <- 0
    
    # changes to make this part easier
    sim$PAR[is.na(sim$PAR)] <- sim$TE[sim$EXTANT] <- 0
    
    # data frame with current and new species numbers
    numbers <- data.frame(cur = 1:length(sim$TS), orig = 1:length(sim$TS))
    # need this to have correct naming conventions
    
    # for each fossil occurrence
    for (i in 1:nrow(fossils)) {
      # change count as needed
      if (fossils$Species[i] == prevFossil) {
        count <- count + 1
      } else {
        count <- 1
        prevFossil <- fossils$Species[i]
      }
      
      # take fossil sampling time
      sampT <- fossils[i, ]$SampT
      
      # and species number
      nSp <- fossils[i, ]$Species
      
      # if sampT is out of the time nSp was alive, error
      if ((sampT > sim$TS[nSp]) || (sampT < sim$TE[nSp])) {
	print(sampT)
	print(sim$TS[nSp])
	print(fossils)
	print(sim$TS)
        stop("Fossil occurrences must fall during corresponding species' period")
      }
      
      # first we need to find the position of the fossil on sim
      
      # get daughters of nSp
      daug <- sim$PAR == nSp
      
      # if nSp does not have daughters
      if (sum(daug) == 0) {
        pos <- max(which(sim$PAR < nSp)) + 1
      } else if (sampT > max(sim$TS[daug])) {
        # if sampT is higher than the age of all other daughters of nSp,
        # make it the first daughter
        pos <- min(which(daug))
      } else {
        # if there are daughters with a higher age, it will be younger than those
        pos <- which(sim$TS == min(sim$TS[daug][sim$TS[daug] > sampT])) + 1
      }
      
      # before and after this position
      before <- if (pos == 0) 0 else 1:(pos - 1)
      after <- if (pos > length(sim$PAR)) 0 else pos:length(sim$PAR)
      
      # get parents that need to be changes
      changePAR <- sim$PAR >= pos
      previousPars <- sim$PAR[changePAR]
      numbers[numbers$cur >= pos, 1] <- numbers[numbers$cur >= pos, 1] + 1 
      
      # change corresponding parents
      sim$PAR[changePAR] <- sim$PAR[changePAR] + 1
      
      # add new parent to the vector
      sim$PAR <- c(sim$PAR[before], nSp, sim$PAR[after])
      
      # and change the easy sim elements
      sim$TS <- c(sim$TS[before], sampT, sim$TS[after])
      sim$TE <- c(sim$TE[before], sampT, sim$TE[after])
      sim$EXTANT <- c(sim$EXTANT[before], FALSE, sim$EXTANT[after])
      
      # find original species number
      nSpOrig <- numbers[numbers$cur == nSp, 2]
      
      # add new name
      newName <- paste0("t", nSpOrig, ".", count)
      names <- c(names[before], newName, names[after])
      
      # add to sampled names
      sampledNames <- c(sampledNames, newName)
      
      # change fossil species names as needed
      fossils$Species <- ifelse(fossils$Species < pos,
                                fossils$Species,
                                fossils$Species + 1)
    }
    
    # change back
    sim$PAR[sim$PAR == 0] <- sim$TE[sim$EXTANT] <- NA
    
  }
  
  #construct the phylogeny:
  
  # make TE sensible
  sim$TE[sim$EXTANT] <- 0
  
  # aux function
  all.dir.daughter <- function(lin, x) {
    # all.dir.daughters returns the name of each direct daughter species
    # x = a simulation from paleobuddy
    # lin = a numeric specyfing the name of a lineage
    return(which(x$PAR == lin))
  }

  # current node
  curNode <- length(sim$TE) + 1 
  
  # create the edge matrix
  edge <- matrix(nrow = 1, ncol = 2, data = c(curNode, NA)) 
  
  # lineages which the function already put in the phylogeny
  passed <- vector()
  
  # current lineage
  i <- 2 
  
  # lineages which the function still has to solve (at least)
  lins <- c(1, 2)
  
  # internal variable to help control the node function
  jump <- 0 
  
  # number of nodes in the phylogeny
  nNode <- length(sim$TE) - 1
  
  # vector storing the node corresponding to each birth
  birthsNode <- rep(NA, times = length(sim$TE)) 
  birthsNode[2] <- curNode
  
  # needed for debugging
  counter <- 0

  # while some tip does not have a place in the phylogeny
  while (length(lins) > 0) {
    # find daughters
    dau <- all.dir.daughter(lin = i, x = sim)
    dau <- dau[!(dau %in% passed)]

    # if lineage has daughters
    if (is.numeric(dau) & length(dau) > 0) {

      # if a whole clade has very recently been put in the phylogeny
      if (jump == 1) {
        curNode <- max(edge) + 1

        # append it to the edge matrix
        if (is.na(edge[nrow(edge), 2])) {
          # if there is no edge there currently
          edge[nrow(edge), 2] <- curNode
        } else {
          # if there is
          edge <- rbind(edge,
                        matrix(nrow = 1, ncol = 2, 
                               data = c(prevNode, curNode)))
        }
        
        # update birthsNode
        birthsNode[dau[1]] <- curNode
        
        # update jump
        jump <- 0

      # if the current lineage is a non-monophyletic branch
      } else { 
        # update curNode
        curNode <- curNode + 1
        
        # append to edge matrix, as above
        if (is.na(edge[nrow(edge), 2])) {
          edge[nrow(edge), 2] <- curNode
        } else {
          edge <- rbind(edge,
                        matrix(nrow = 1, ncol = 2, 
                               data = c(curNode - 1, curNode)))
        }
        
        # update birthsNode
        birthsNode[dau[1]] <- curNode
      }

      # update edge
      edge <- rbind(edge,
                    matrix(nrow = 1, ncol = 2, data = c(curNode, NA)))
      
      # update lineage list and current lineage
      lins <- c(lins, dau[1])
      i <- lins[length(lins)]
    }

    # if lineage has no daughters
    if (is.numeric(dau) & length(dau) == 0) {

      # append lineage to the edge matrix
      if (is.na(edge[nrow(edge), 2])) {
        
        # if there is no edge there currently
        edge[nrow(edge), 2] <- i
      } 
      
      else {
        # if there is
        edge <- rbind(edge, 
                    matrix(nrow = 1, ncol = 2, 
                           data = c(max(
                             edge[!(duplicated(edge[,1]) | 
                                duplicated(edge[,1], fromLast = TRUE)), 1]), i)))
      }
      
      # we put the lineage on the phylogeny
      passed <- c(passed, i)
      
      # update lineage list and current lineage
      lins <- lins[-length(lins)]
      i <- lins[length(lins)]
    }
    
    # this means that the function reached the end of the lineage of the curNode
    if (sum(edge[, 1] %in% curNode) > 1) {
      # the warning here only "affects" a a condition which is never satisfied
      # (jump when there is previous opened edge).
      suppressWarnings(
        {prevNode <- 
          max(edge[!(duplicated(edge[, 1]) | 
                       duplicated(edge[, 1], fromLast = TRUE)), 1])})
      
      # update jump
      jump <- 1
    }

    # registering bugs (if any)
    counter <- counter + 1
    
    # if the function ran for too long
    if (counter > 10*dim(edge)[1]) {
      return("The function is lost and seems that it will not find a phylogeny.
             Please report this error and provide this simulation for debugging")}

  }

  # calculating edge length
  edgeLength <- vector()
  for (i in 1:nrow(edge)) {
    # make auxiliary variables
    aux1 <- edge[i, 1]
    aux2 <- edge[i, 2]

    # if the branch is a tip
    if (aux2 <= length(sim$TE)) {
      # calculate length
      edgeLength[i] <- sim$TS[which(birthsNode == aux1)] - sim$TE[aux2]
    } else {
      # calculate length
      edgeLength[i] <- sim$TS[which(birthsNode == aux1)] -
                        sim$TS[which(birthsNode == aux2)]
    }

  }

  # Tyding all together to create the phylo object
  phy <- list(tip.label = paste0("t", 1:length(sim$TE)),
    edge = edge, 
    edge.length = edgeLength, 
    Nnode = nNode, 
    root.edge = sim$TS[1] - sim$TS[2])
  
  phy$root.time <- sim$TS[1]
  phy$node.label <- seq(from = length(sim$TE) + 1, 
                        to = length(sim$TE) + 1 + nNode)
  
  # if fossils are provided
  if(!is.null(fossils)){
    # alter names to label occurrences
    phy$tip.label <- names
  }
  
  class(phy) <- "phylo"
  
  return(phy)
}
